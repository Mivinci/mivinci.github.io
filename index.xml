<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>被门夹过的核桃还补脑吗</title><link>https://xjj.pub/</link><description>Recent content on 被门夹过的核桃还补脑吗</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>© 2018-2022 XJJ</copyright><lastBuildDate>Wed, 13 Apr 2022 14:40:48 +0800</lastBuildDate><atom:link href="https://xjj.pub/index.xml" rel="self" type="application/rss+xml"/><item><title>2022 年怎么开始学 Go</title><link>https://xjj.pub/tech/go/</link><pubDate>Wed, 13 Apr 2022 14:40:48 +0800</pubDate><guid>https://xjj.pub/tech/go/</guid><description>纠结了很久是否要水这篇文章，因为实在是太没技术含量了，但最近实在是看不下去了，身边的同学越来越多开始学 Go 但又被国内的教程带偏，加上想到之前的文章不也没技术含量么，所以还是决定动笔。 从我开始接触 Go 的 2019 年到现在，Go 共发生了 3 次重大更新（包括上个月发布的 1.18 版本中正式加入的 Go 泛型）。这是像 Go, Rust 这种比较年轻的语言的特点，特别是 Rust 这种由社区驱动的语言更是更新频繁得离谱。
所以唯一靠谱的只有官方文档。相比 Rust，由于由 Google 一个团队维护，加上对简洁高效的追求，Go 并不太迎合社区需求，没有拼命增加新特性，从今年才发布发型就可看出 Go 的相对保守，我记得从我开始接触社区就有大量提议泛型的声音。
其实 Go 的定位就是高性能网络编程，而这块往往让使用传统编程语言的程序员头疼，也是 Go 团队发明 Go 的初衷。在高效和简洁间寻找平衡，答案就是 Go。
但不要误会，这篇水文题目叫怎么「开始」学，而不是怎么学，我也不会介绍 Go 的历史。意在讲下目前 2022 年 Go 的正确打开方式，包括正确安装环境、工具链使用、代码组织、命名规范、包管理、常用生产发布方式、文档阅读和目前的生态状况。本文也会跟随 Go 的更新进行内容的修改。
第一原则 任何领域都有所谓的 first principal，而编程界的第一原则就是「先看官方文档」没有什么比官方文档更准确。要是你嫌官方文档都是英文看不懂，那你可能不适合研究这行。目前 Go 的国内技术沉淀还不像 Java 那样，充分得可以自给，能给初学者足够多的正确信息，毕竟 Java 主宰市场那么多年。想要学会一门还在发展中的新语言，你不得不直接阅读英文文档和开源项目源码，后者是因为 Go 的模式和传统设计模式不太一样，更何况像模式这种东西也只能靠大量写项目、看大量项目源码才能掌握和正确使用，不是在课上靠老师念念 PPT，学生上讲台耍耍嘴皮子就能学会的 /doge。
另外，技术类的英文（任何语言）都写的很直接，不拐弯抹角，读不懂往往是因为里面的技术名词不熟悉，还有就是计算机的基础知识不扎实，很多文档里一句话带过的内容可能需要深刻的计算机知识才能理解。所以我一直说基础很重要，基础教学很重要，但实际上国内高校的操作。。。不说也罢！
不多说，进入正题。
动手前 你得知道 Go 之前的官网是 golang.google.com，所以严格来讲，Go 是谷歌的编程语言而不是程序员的，我们能用完全是因为谷歌的用爱发电，这么说可能有点过，因为站在理想主义角度，当一个项目变成开源项目后，他本身的所属性质可能就会改变，但不管怎么说，当你在使用（白嫖）一个东西的时候不要忘记它来自哪里。
现在 Go 官网是 go.dev，这似乎是现在的趋势，像 svelte.</description></item><item><title>用 WSL2 在 Windows 上搭建 Linux 开发环境</title><link>https://xjj.pub/tech/wsl2/</link><pubDate>Sat, 26 Mar 2022 14:40:48 +0800</pubDate><guid>https://xjj.pub/tech/wsl2/</guid><description>WSL (Windows Subsystem for Linux) 是 Windows 自带的 Linux 子系统功能，目的是在 Windows 上运行 GNU/Linux 环境，包括大多数命令行工具和一些应用程序，没有传统的虚拟机（如 VMware）或 DualBoot 设置的开销。WSL2 是 WSL 的第二个版本，比第一个版本有更高的性能，具体差别见官方文档 Comparing WSL and WSL2。这篇文章简单记录下 WSL2 的启用方式，你也可以直接根据 官方文档 来操作。
启用 WSL2 目前官方给了自动和手动两种启用方式，较新的 Windows10 和 Windows11 可以使用自动的方式。
自动 以管理员身份打开 PowerShell 或 CMD 运行下面命令即可。
1 wsl --install 手动 启用 Windows 子系统和虚拟机功能。 因为 Windows 默认关闭这两项功能。这一步有图形界面和命令行两种方式。使用命令行的话依次运行下面两个命令即可
打开子系统功能
1 dism /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 打开虚拟机功能
1 dism /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 使用图形界面的话，首先打开 “控制面板”，然后点击 “程序”，再点击 “启用或关闭 Windows 功能”，勾选 “适用于 Linux 的 Windows 子系统” 和 “虚拟机平台”，最后点击 “确定”。然后会要求重启，立刻重启即可。</description></item><item><title>阅读清单</title><link>https://xjj.pub/read/</link><pubDate>Fri, 11 Mar 2022 11:24:06 +0800</pubDate><guid>https://xjj.pub/read/</guid><description>组成原理 CrashSource - Computer Science 深入理解计算机系统 (CSAPP) 编译原理 The Implementation of Lua 5.0 QuickJS Javascript Engine Crafting Interpreters 中间件 Redis 设计与实现 分布式缓存 微服务 Pattern: Service Mesh 指南 CS 自学指南 资讯 GitHub Trending 阮一峰的网络日志</description></item><item><title>A Thought of Open-sourcing</title><link>https://xjj.pub/idea/open-sourcing/</link><pubDate>Sun, 27 Feb 2022 22:01:35 +0800</pubDate><guid>https://xjj.pub/idea/open-sourcing/</guid><description>Open-sourcing does not mean making your codes public so others can use them, it never did.
Instead, it means a chance that everyone can access and help.
Open-sourcing is a way of struggling that the idealists are using in this ridiculous world to reach their wishes. All the ideas shared through opening sources more or less contribute to a brighter and more diverse world.
To open source is to build up trust between you and the world.</description></item><item><title>对“面向对象程序设计”的质疑</title><link>https://xjj.pub/idea/oop/</link><pubDate>Wed, 08 Dec 2021 23:50:35 +0800</pubDate><guid>https://xjj.pub/idea/oop/</guid><description>当讲到面向对象程序设计时，首先告诉你的就是它的三要素：封装、继承、多态。我不确定这里的 “要素” 是不是指的 OOP 的必要条件，即面向对象的程序都有这三个特点，这很奇怪，但几乎所有的书和课堂都在传递这个观点。这是我质疑的第一点，我认为这种总结是错误的，是对 OOP 的误解。
面向对象思想的出现是为了程序的重用性和扩展性，这是前提。
封装
不知从何时起，人们把封装等同于将一堆变量和函数塞进一个叫 class 的东西里。更有语言将 class 作为写代码的开端，并宗教式地宣扬 “一切皆对象” 这种说了当没说的口号。
封装的目的是对 “什么是封装” 最好的阐述，即使用某种机制将一些数据和逻辑隔离起来并向外界提供访问或操作的接口，这样外界并不感知被封装对象的具体实现。显然，这里的机制并不仅仅局限于 class。像结构化类型（struct） 或包（package）模块（module）层面的隔离，甚至是一个函数都能体现这个目的。
继承
这是宣扬 OOP 解决了代码重用性问题的人最大的信仰，因为在他们看来，他们定义的类和类之间必须有所属关系，如果你接受过这种 OOP 的教育，应该对这个例子很熟悉：
1 2 3 4 5 6 7 8 9 10 11 12 13 class Animal { void speak() { /* speak */ } } class Dog extends Animal { @override void speak() { /* bark */ } } class Cat extends Animal { @override void speak() { /* mew */ } } 这群 OOP 狂热分子认为不同的动物就应该属于一个共同的 “动物” 类，但不同的动物对同一个行为（如叫）有不同的表现，所以需要使用 “方法重写” 这种他们认为很高级的特性来实现，并觉得这种实现很有设计感。</description></item><item><title>我可能实现了个高性能 HTTP 路由器</title><link>https://xjj.pub/tech/web/</link><pubDate>Mon, 22 Nov 2021 22:37:55 +0800</pubDate><guid>https://xjj.pub/tech/web/</guid><description>背景 Go 语言标准库提供了完整的 HTTP 协议解析器，并将请求的处理抽象成了 http.Handler 接口，该接口就是传统意义上的 controller。只要对象实现了该接口的 ServeHTTP 方法，就能传入 http.Server，接收并处理 HTTP 请求。如下
1 2 3 4 5 6 7 8 9 type handler struct {} func (h handler) ServeHTTP(w http.ResponseWriter, r *http.Request) { // 处理请求 } func main() { http.ListenAndServe(&amp;#34;:8000&amp;#34;, new(handler)) } 这样，handler 就能收到并处理任何发到 8000 端口的 HTTP 请求。但我们大多数时候需要使用不同的 handler 来处理不同方法、不同路径来的请求，如下面 2 个常见的请求需要 2 个 handler 来分别处理（为方便显示，省略了协议和域名部分）。
GET /user/profile GET /book/introduction 一种最简单的实现方式是在上面 handler 的 ServeHTTP 方法里使用条件判断，如 switch，匹配请求的方法和路径，再在 case 里调用对应的函数来处理。这种方式实现起来十分简单而且处理得很快，但对于有很多路由的服务端程序，需要写很长的条件判断语句。基于 HTTP 的微服务框架 twirp 就是使用的这种方式来处理不同路径的请求，因为微服务一般是不需要很多路由的。</description></item><item><title>对技术的偏见、拖延症</title><link>https://xjj.pub/idea/prejudice-against-technology/</link><pubDate>Tue, 16 Nov 2021 02:18:48 +0800</pubDate><guid>https://xjj.pub/idea/prejudice-against-technology/</guid><description>不知道其他人是怎么样，但我从来没有在技术的学习上获得过以前上学时那种花很久解决一道数学题时的开心，即使是我花了多倍的时间学会一个技术。我说的技术就是指的计算机相关的技术，不论是计算机底层的原理还是上层的各种应用和开发技术。
可能是因为这些技术都是人造的，而数学这种东西是自然的吧（别跟我说数学也是人发明的，人发明的是数学符号，数学逻辑本身向来都是存在的，且被人类发现并用那些符号所描述）在技术的学习过程中，就我而言就是四件事：看文档、看源码、看著作、动手。无一例外，这四件事都是在接受别人规定好的东西，或是在别人规定好的模式中操作。但这些规定几乎是合理的，因为我们的生活条件是在这些规定、技术中提高的，正如你能在一块不到 1 毫米厚的玻璃板上看到这些文字。
那种开心，就算是刨根问底地搞明白内存中数据怎么排布，电子怎么在各个门里面横跳也不会出现，因为你始终明白就算是个组成 晶体管的原料也是由人们堆砌而成。
我喜欢技术，但也对它有所偏见。
拖延症
四个月前，也就是本科刚毕业时，因为我不是科班的，所以决定要系统地学习编译原理，操作系统，计算机网络，顺便设计一个简单的协议用来实现一个 RPC 框架（最后这个是我一直想干的事）。虽然这些有所了解但远没达到系统性的认识，更别说一些细节上的东西。随后的暑假感觉做了很多事但好像又什么也没做，就看了点 Unix 网络编程、IO 复用，Redis 事件库、也跟着一个 Google 工程师的博客试着实现自己的编程语言（也没坚持到最后）。但都是囫囵吞枣，什么也没学会，要我讲也讲不明白。然后就临近开学，导师布置的任务也提上日程了。
暑假唯一干成的事就是正在用的这个叫 Minima 的博客主题，并且现在也在维护。其他没干完的事情只能抽空做了，因为研究生比我想象中的忙太多，没必要的课和杂七杂八的事就能花我大半的精力。。。
希望明年开学前能够把之前拖欠的任务完成，还有刷力扣。</description></item><item><title>第一次 PR</title><link>https://xjj.pub/idea/first-pr/</link><pubDate>Sun, 14 Nov 2021 23:18:49 +0800</pubDate><guid>https://xjj.pub/idea/first-pr/</guid><description>昨天在 B 站上看到关注的程序猿 UP: Steven 发布了一条视频，介绍了他开发的用于检测网页元素边距的开源项目 SpacingJS，下面是该项目官网的截图
使用方式很简单，官网上也写得很清楚，只需要将 SpacingJS 的 CDN 引用到自己的项目即可，不过我还是觉得这类项目最成浏览器插件最好，于是啊，很快啊！我就去它的仓库发了条 issue 说希望能做成谷歌浏览器插件。又很快啊！Steven 就回我了，说他有空看看插件开发文档。
于是第二天，我还是自己去看了文档，然后很快就把插件搞出来了（因为和我想的原理一样简单），然后给 SpacingJS 仓库提了个 PR。然后在第三天，我的 PR 被 Steven 合并了，于是我算是完成了人生第一次参与开源项目合作开发，虽然是个很简单的浏览器插件。目前 SpacingJS 已经可以在 谷歌浏览器插件商店已经可以下载这款插件了。
其实之前也提过两次 PR，一次是将我写的 Hugo 主题 Minima 推到 Hugo 官方主题的仓库中，让我的主题能显示在 Hugo 的官方主题页面上，另一次是将我写的匿名评论插件 OvO 推到 js.org 的仓库中，这样就能通过 ovo.js.org 访问到 OvO 的 demo 官网了，显得比较像个正儿八经的前端开源项目 233。
但那两次的意义跟这次还是不一样的。</description></item><item><title>关于 Minima 这个主题</title><link>https://xjj.pub/idea/minima/</link><pubDate>Sat, 13 Nov 2021 18:33:48 +0800</pubDate><guid>https://xjj.pub/idea/minima/</guid><description>距离 Minima 的第一次代码提交已经过去 3 个月了，中间经历了很多次迭代，有小功能的添加，也有界面的大改，从来没有哪个项目让我坚持维护了这么久，这可能就是社区驱动的优势（虽然可能只有一两人在用，哈哈）。不过，重要的不是有几个人在用，而是时不时会受到邮件或是 GitHub 发来的 issue 通知，告知我哪里有 bug 或是希望我加个什么新功能，这时候就会让我有维护下去的动力。不过他们可能只是在尝试不同的主题，并不会真的使用我的，就像我最开始玩自建博客的时候一样，花很多时间来挑主题，结果最后还是自己写了一个，嚯嚯。
截止到现在，Minima 只获得了 12 个 star 和 11 个 fork，哈哈有点惨，不过有人会 fork 我是没想到的，估计是想自己拿去改改吧。上个月收到一个 PR，帮我改了一个首页的 bug，我看代码没问题就直接给合并了（原来 PR 被合并后就能自动成为 contributor）刚刚去 他主页 看了看，还在用我的主题，不过他稍微改了改样式，哈哈。
Minima 原本是 Hexo 的一个主题，因为其实一直都想写个 Hugo 主题来用，所以就去 Hexo 的 主题官网 找了个喜欢的来抄了抄 UI，于是就看到了 Minima。一是因为我本来就喜欢极简风格的主题，二是这种风格的界面好实现，没有很花哨的动画。其实 Hugo 的主题很多都是极简的（因为 Hugo 是 Go 语言开发的，所以很多主题作者可能不是前端出身，也就没有很多很炫的 UI）。不过我觉得 Hugo 的极简主题还是差了点设计感，也有些过于简单了，一直没找到能满足我需求的主题。
目前，我的 Hugo 版 Minima 仍保留了原版 Minima 的所有功能，包括暗黑模式、分类和标签索引等，另外还增加了 KaTeX 和 Mermaid 支持，因为我很多时候写的东西里面需要显示公式和图表，在 示例网页 可以查看效果。另外原版 Minima 的 VSCode 风格的代码高亮是我见过做的最好的，所以当时花了很久，才将代码高亮调得和原版比较接近，因为在代码关键字识别准确度上 Hugo 还是比 Hexo 要弱一点。</description></item><item><title>PPT 不是笔记</title><link>https://xjj.pub/idea/ppt/</link><pubDate>Sun, 07 Nov 2021 07:02:28 +0800</pubDate><guid>https://xjj.pub/idea/ppt/</guid><description>今天是有点生气的，因为做的 PPT 被别人改了，而且被改的是内容，也就是 PPT 里的文字和图片，要是被改的是样式或颜色，也许会觉得没什么，毕竟人与人的审美是有差异的。 改后的版本用应试教育的产物来形容最合适不过，一股浓浓的应试英语味儿，像极了考研复习时看的某艳英语课里讲的句式、用法，不过可能我对某艳英语有误解哈，毕竟看了两节课觉得死板无聊发音问题就再也没看了，呵呵。
被改后的版本主要有两个问题：一是我原本简短的内容被以笔记的写法加了不少补充，二是部分句子被改成了应试英语的表述习惯。
我一直认为并且相信 PPT 发明出来是辅助讲解的，然而现实中，无论是小组汇报展示做的 PPT，老师讲课用的 PPT，还是学术讲座 PPT，都恨不得将所有要讲的内容写到里面。一个有效的 PPT 应该只有图片和一些关键词或短语，无论是英文还是中文 PPT，都不应该使用句子，更不应该使用段落。 因为你是一个演讲者，而不是一个念 PPT 的机器。台下的观众应该从你的声音中获取到信息而不是通过自己看 PPT。演讲的是人，而不是 PPT。
无论是演讲还是汇报展示，正确的做法是「看图说话」，PPT 上只需要放图和关键词，图背后的内容需要由演讲者自信地讲出来。这需要演讲展示者理解图背后的内容，最好提前写好稿子，但并不意味着完全照着稿子念，而是心中有数。站在讲台上，观众的注意力应该是在你身上而不是在读 PPT 上。
从中学开始，都存在并且普遍存在一个现象，老师授课是用的 PPT 都写得很详细，详细得似乎不需要老师的讲解。听上去是不是觉得很棒，但这样的教学是死的。有效的教学应该是老师与学生的互动，内容需要老师在黑板上带着学生走前人的路，遇到前人遇到的问题，像前人一样思考。教学的重心应该是讲为什么，而不是讲是什么。
只有这种亲自带领着学生一步步走向真理的教学方式才能让他们深刻认识这个学科，才能教会他们思考，才能让他们主动完善未涉及到的东西。而不是一下子由 PPT 将所有东西呈现出来，恨不得一下子灌进学生脑子里，这样学生到最后什么也不会学到，更不知道学了有什么用，也不会有正确的思考，也就别指望在基础领域有突破。我想这是国内绝大多数高校包括 C9 高校都普遍存在的问题。
更糟糕的是，有的学校上课用的 PPT 是一届届传承下来的，后面的老师接来就用，上课就照着念，完全是在浪费学生的时间。学不到正确的思考，不如自学些对生存更有用的技能去找工作，但这样的话本科和专科还有啥区别（然而事实上，那些经常逃课只通过自己自学的人往往比按照学校教学和培养方案学习的人找到更好的工作）
不少人有做笔记的习惯，特别是女生。做笔记有用，但其中有一种做笔记的方式（经常被评为优秀笔记）我觉得是有问题的，即不管什么学科都通过不同的颜色勾画不同的内容和做很多注释这种方式做笔记。你说这样你就知道哪些颜色的字是讲什么内容了的呀。的确，这种方式可能会让你知道哪些段那几行字在讲什么，但你真的需要知道这些吗？你做的不过是认识了别人的写作风格。你应该要做的是，或者你应该继续做的是抛开这些别人写的，重新思考别人做的东西本身，你应该做的是建立起这东西的框架。为什么需要这个？它是如何产生的？用它能解决什么问题？它和其他东西有什么交织？未来它还会存在吗？这才是学习新东西时应该去做的。 这很难，特别是在你不知道如何正确思考的情况下，完成上述过程几乎不可能，所以我们需要在教学中让学生学会在不同学科中如何正确地思考，而不是一味地灌输知识，应付考试。拿起纸和笔，亲自从头进行几遍推演，比任何笔记都有效。
有时候在想这些现象的出现是不是因为国人的思维习惯自古就是这样。我们似乎一直都认为在做之前我们得先汲取足够多的知识，以一种背课文的方式学习，且我们缺乏批判和质疑的勇气，在师生间总是有种阶级般的隔膜。加上我们不是近代科学的发源地，大体上丧失了思考主动权。这样便使得我们的教学极易陷入盲目灌输大量知识的困境。
但是，上述期望的教学方式对老师的要求是很高的，需要老师足够深入地掌握他教的学科，而现实是国内师资远远不够，高水平的教师更是量小力微，很多老师甚至要同时教授多门课程，再加上扩大的招生，教学资源和课堂效率可想而知。更糟糕的是很多学校过于看重学术威望，把高水平论文数当做指标，导致老师不得不轻教学重科研，但高水平科研的前提正是正确思考的能力，这又回到了开头的问题，所以说国内的教育陷入了一个恶性循环中。这个循环不打破，几十年后可能会出现人才严重不足的局面，这对国家发展是巨大的阻碍。
你可能会说国情是这样，的确，现在的制度或许是最符合当下国情的，国家的主要注意力不在教育问题上，也许某一天各行各业都会迎来改革。</description></item><item><title>更令人失望的高等教育</title><link>https://xjj.pub/idea/more-disapointing-education/</link><pubDate>Fri, 01 Oct 2021 22:44:16 +0800</pubDate><guid>https://xjj.pub/idea/more-disapointing-education/</guid><description>当了一个月的硕士研究生（下简称研究生），用一个词来形容的话，那只能是「失望」了。首先是垃圾的在线选课系统，我琢磨着就算是单机架构也不止这点并发能力。其次还是关于选课，按照学校要求，研究生需要在一年内修满 33 个学分（专硕少 5 分）。什么概念？就是研一除了政治英语这种必修，至少要上 8 门选修课&amp;hellip; 听上去好像不是很多对不对？可一次课为 4 节连上，加上中途 3 个短暂的课间共 210 分钟，上一次课就是一上午或一下午或一晚上。更离谱的是这些课均匀的分布在每一天&amp;hellip;
本科的时候我说过「上课耽误学习，不上课耽误学位」，这不还得说 3 年·。我不是说研究生上课不好，只能说是跟好一点也不沾边，当然政治课除外 /doge。很多课根本就没必要开设，比如像什么面向对象设计模式啥啥的，这种东西是个脑子正常的人都能花几个小时阅读完撸点代码就明白了，更何况这些东西是需要足够多的项目积累才能真正掌握的。非要硬生生开 32 个学时看老师念 PPT，我人傻了都&amp;hellip;
还有机器学习入门和一系列带高级的课程，哪一个不是能买本靠谱的书最多一个月就能自学完的。对于一些天赋选手，半个月都绰绰有余。然而现实是这些课都是 32 学时起步。
就为了应付这些课程和考试，就会花掉研一大半的时间和精力，我琢磨着各个都是人上人呢，光靠研二一年就能完成科研并发表有效论文。噢忘了！大多都是为了毕业才凑论文的，那没事了。
毫不夸张地说，就计算机学科而言，这些专业课程都是本科应该完成的。哦对，本科也是为了上课而拉时长，没时间学这么多，呵呵。
不过我想这也是必然的结果。除开一些人文和数学上的基础课外，本科的后三年完全有可能通过自学成为一个领域的专家，同时拥有较广阔的知识体系。然而现实是学校开设了又长又没用的必选修课来充斥学生枯燥的生活。
这种教学方式简直是毒药。在这种模式下，确实让大部分人，特别是享乐主义，以一个修完专业课程毕业生的身份，顺利找到工作。实际上工作才使他们正式开始学习生涯&amp;hellip; 而他们的学位也仅仅是个身份。
对于一部分对工作不满意，或是压根没找到工作的人，他们选择了继续读书，而这部分人却是研究生里的绝大多数，所以研究生新生的质量是很低的，很难不这样说。
研究生，可能是他们给自己的第二次机会，如果在和本科同样的模式下培养，那这瓶毒药，只会让他们换个听上去似乎更高级的身份，找到一份本科生就能找到工作，甚至更差。
可能会有人说我在崇尚内卷，很难不反对，内卷这个词已经被玩儿得成为工作学习的同义词了。只要有人在学习，在工作，就会被说成在卷，好像是什么见不得光的事情一样。的确，在大学寝室只要有人学习就会被嘲讽，学习已经变成需要偷偷摸摸进行的事情了 233&amp;hellip;
这种人一般是恐惧知识的，试图通过嘲讽别人来证明自己的价值。现有的高等教育模式是给这类人的福利，让他们不通过有效学习就能获得和其他人一样的待遇和结果，所以他们其实是聪明的。
我同时也极其讨厌像上进、努力、学霸这些说法，我觉得很多被当作需要所谓努力的事情，都是这个时代对人类的基本要求，但大部分人都在自己的制度和要求中圈地自萌，甚至要求别人遵循他的制度。我认为当一个人在挑战也许不可能完成的事情的时候才配得上努力这类词。</description></item><item><title>零宽度短网址</title><link>https://xjj.pub/tech/zero-width-url-shortener/</link><pubDate>Sun, 29 Aug 2021 13:48:59 +0800</pubDate><guid>https://xjj.pub/tech/zero-width-url-shortener/</guid><description>首先解释一下什么是短网址。你收到过的短信里应该有长成这样的网址：https://t.cn/a6v27，这就是一种短网址，或者叫短链。点击该网址，会发现跳转到了一个拥有很长地址的网站。这种通过短网址跳转到原网站的技术主要有两个好处：
一是对短信发送方，可以减小短信内容，降低流量消耗，我们知道网络运营商是按流量使用大小计费的。二是对用户来说，短网址较原本的长网址更美观，同时也使得短信内容更加紧凑，便于用户阅读。
短网址的核心原理很简单，一句话概括就是：短网址服务器将对某个短网址的访问请求重定向到其对应的原网址。所以需要服务端维护短网址到原网址的映射，也需要向原网址所有者提供注册映射的接口（一般为网页）。
当然，需要注意的是，选用的短网址生成算法要保证极小的碰撞率，同时要避免被批量刷出。不过这不在这篇文章讨论的范围。
进入正题，所谓零宽度短网址就是指没有唯一代表该网址的部分，如上面例子中的 a6v27 部分。以 zws.im 为例，该平台生成的短网址全都长这样：
1 https://zws.im 没错，就是它本身的样子。那他怎么识别不同原网址？原理其实很简单，该平台也对其原理做了说明。我们知道 unicode 字符集包含了地球上几乎所有的符号文字。而在很多国家的语言中，‎都有连字1 的现象，比如波斯语中的「我想要」可写为下面两种形式2
第一种就是连字形式。为避免字体文件将字符渲染成连字形式，unicode 字符集中出现了不占宽度的字符，如上图中的第二种写法中的红线部分。该字符的 unicode 码为 200b，在 utf8 编码中占 3 个字节，其 HTML 代码为 &amp;amp;zwnj。使用了该零宽度字符后，字体文件就不会将可以连字的字母进行连字处理。
但是，这种零宽度字符是肯定会占空间的，你可以打开浏览器的控制台运行下面代码试试看
1 &amp;#39;\u200b&amp;#39;.length // 1 我们知道 JavaScript 对象的 length 属性返回的是字符串中字符编码单元的数量3，故这行代码会返回 1，表示有一个字符。所以使用这种字符来生成短网址的方法，并不能体现上述节省流量的好处。更直观一点，我们拿一条该平台生成的短链接来试试
1 &amp;#39;https://zws.im/󠁧‌󠁱󠁫󠁶󠁦󠁴&amp;#39;.length // 28 可以看到，现在返回了 28，而不是本身 15 的长度，说明在地址后面还有 13 个零宽度的字符。不过我觉得这种零宽度短链接是种很酷的东西，所以我又收集了几组零宽度字符，它们的 unicode 码分别是
200b ~ 200f 2028 ~ 202e 2060 ~ 206f feff, 180e 打算用这些字符的不同数量的排列组合对应到正整数上，由此自己实现一个零宽度短网址生成器（挖坑+1）。</description></item><item><title>一个用于展示个人项目的网页生成器</title><link>https://xjj.pub/tech/x26/</link><pubDate>Fri, 27 Aug 2021 14:21:29 +0800</pubDate><guid>https://xjj.pub/tech/x26/</guid><description>去年考研复习时就想做个个人项目聚合网页，用来统一展示项目，包括项目名、项目简介、项目标签、仓库地址和在线预览地址等等。结果鸽了快大半年了，不过现在终于做好了，取名叫 x26，效果如下图所示，或直接在线浏览 👀
个人觉得挺好看 😆 每个方块表示一个项目（第一张图），点击方块可以弹出项目详情（第二张图）方块的数量、大小、位置和里面显示的内容都是可以自定义的（具体使用方法见下）除了展示项目，还可以把 x26 当个人首页使用，甚至可以用来显示简历，若你愿意，hehe。
使用 只需要 6 步，就能拥有一个 x26 小站。
第 1 步 - 安装 在使用之前，确保你已经安装好 Node 和 Git 环境。首先克隆这个仓库，然后进入其根目录
1 2 git clone git@github.com:mivinci/x26.git cd x26 x26 使用 pnpm 管理 node 模块，所以需要先安装 pnpm，以 npm 为例
1 npm i -g pnpm 然后安装 x26 依赖
1 pnpm i 第 2 步 - 预览 成功安装依赖后，运行下面命令，然后打开浏览器输入 localhost:3000 预览当前的网页效果
1 pnpm dev 第 3 步 - 配置 这一步是 x26 的核心步骤。x26 通过识别配置来决定渲染的内容和样式，支持本地和远程两种配置方式。</description></item><item><title>几个在线汇编模拟器</title><link>https://xjj.pub/tech/asm-simulator/</link><pubDate>Mon, 23 Aug 2021 20:50:50 +0800</pubDate><guid>https://xjj.pub/tech/asm-simulator/</guid><description>今天来水一篇文章，这几天在看计组，且在试着用 C 语言模拟一个 16 位的计算机和其汇编器，选用的指令集架构是 CASL。为了搞清楚机器是怎么在内存中维护和访问变量，在网上搜了几个有图形界面的在线汇编模拟器。
8 位 https://schweigi.github.io/assembler-simulator 16 位 https://parraman.github.io/asm-simulator/ Intel 8086 https://yjdoc2.github.io/8086-emulator-web/compile 这里简单介绍一下 8 位的模拟器，如下图所示
顶部有三个操作按钮，Run 用来运行左边的汇编代码，Step 用来一行行断点运行，Reset 用来重置模拟器状态，包括清空内存和寄存器的内容。
在汇编代码下方的 Assemble 按钮用来初始化机器状态，包括加载程序和数据到内存以及建立符号表。符号表如图中右下角所示，记录了符号名、在内存中的地址和值。
而右边就是对寄存器、内存和输出的图形显示，首先是寄存器，该模拟器实现了 A, B, C, D 4 个通用寄存器、一个 IP 程序计数寄存器、一个保存栈顶位置的 SP 寄存器和 3 个 1 位的状态寄存器。然后是内存，如图 RAM 部分所示，内存用了 16×16 个格子表示，每个格子存储 1 字节数据，所以该模拟器只有 256B 的内存空间。
SP 寄存器的值被机器默认设置为 0xe8（RAM 中橙色部分），表示将地址 0xe8 作为栈底，往低位入栈。最后该模拟器将 RAM 中 0xe9 到 0xff 的地址映射到输出，所以最多同时可显示 24 个字符。
另外可以在 RAM 下方的 Clock Speed 处调节时钟频率。</description></item><item><title>OAuth2.0 中的 state 参数</title><link>https://xjj.pub/tech/oauth2/</link><pubDate>Thu, 05 Aug 2021 13:53:48 +0800</pubDate><guid>https://xjj.pub/tech/oauth2/</guid><description>OAuth2.0 协议用于用户授权第三方应用，使之能访问受保护的用户资源。RFC67491 中规定了 OAuth2.0 的 4 种授权方式，分别是：
授权码式（authorization code） 隐含式（implicit） 密码式（resource owner password credentials） 客户端模式（client credentials） 且整个协议过程由 4 个部分组成，分别是：
客户端（client） 资源拥有者（resource owner） 授权服务器（authorization server） 资源服务器（resource server） 前两种授权方式需要客户端在访问授权服务器的 authorize 接口时带上一个 state 参数，用来防御跨站请求伪造（CSRF）攻击。
以授权码方式为例，该方式要求客户端提供一个回调地址（redirection uri）用来接受来自授权服务器带有授权码（code）的重定向请求。即该回调地址是对外开放的，客户端为了确定该重定向的确来自授权服务器，而不是其他由攻击者伪造的请求，就在获取授权码阶段，将一个 state 字段通过 url 查询参数（querystring）告诉给授权服务器，授权服务器在重定向时原封不动的也通过 url 查询参数返回该 state 给客户端，然后客户端通过校验 state 是否正确来判断该重定向请求是否来自刚刚请求的授权服务器，从而达到对 CSRF 的防御。
所以，state 参数的生成和校验需要由客户端妥善处理，且参数值要让攻击者难以在有限时间内试出。在完成一次授权过程后，需要立即销毁该 state 参数，保证每次使用不同的参数值。
https://www.rfc-editor.org/rfc/rfc6749.html&amp;#160;&amp;#x21a9;&amp;#xfe0e;</description></item><item><title>我的博客搭建历程</title><link>https://xjj.pub/idea/blog/</link><pubDate>Tue, 20 Jul 2021 23:35:21 +0800</pubDate><guid>https://xjj.pub/idea/blog/</guid><description>和大多数人一样，我的博客历程从 Hexo 的 NexT 主题开始，并且也经历了从折腾各种主题、各种花里胡哨的功能到极简主义这种寻找所谓「真理」的过程，hhh 😁 。不过和大佬们不一样，我基本没写过什么博客文章，一来是觉得自己对熟悉的东西研究得不够深入，二来就是大多数人在维护博客过程中遇到的问题，我愿称其为学习过程中的「贤者模式」。意思是当学会某个东西的那瞬间，之前决心写篇文章的冲动荡然无存，甚至觉得这么简单的东西写出来不是笑话吗。
不过，我想这种学习过程的贤者时间的产生可能也是因为第一个原因。学会了，但没完全学会。特别是在计算机软件领域，在这个满地框架和各种使用示例的时代，学习成本实在太低，学会使用某个工具或掌握某项技术或许并不要求过多去研究这东西背后的原理。所以，或许当人研究深度的提升会逐渐抵消这种贤者模式的影响。
话题掰回来，第一次使用 Hexo 大概是在 2018 年的暑假，也是我暂停服务端开发转而学习 web 前端的开端，但不久就也对很多人诟病的 node_modules 产生了反感，甚至反胃，也许这就是传说中的「晕包」hhh 😅 。这也是我第一次开始怀疑 web 前端是否在朝正确的方向发展。
于是几个月后，和部分使用过 Hexo 的人一样，开始使用 Hugo，这也是一个静态博客生成引擎，不过它的官网号称世界最快。也许是最快吧（若不考虑 Rust 生态的 mdbook 的话，不过 mdbook 面相的是文档快速生成，并非个人博客，所以两者并不形成竞争关系）但肯定的是 Hugo 比 Hexo 快得多，并且没有庞大的包依赖文件。这得益于 Hugo 的开发语言：Go，这也是我第二喜欢的编程语言（😁 第一当然是 C）
直到现在，本站仍然使用的是 Hugo，主题是使用的我自己开发的 Minima，有兴趣的小伙伴可以试试，顺便三连点个 star。
其中，中途还接触过动态博客，如 wordpress，typecho，甚至还自己开发过博客引擎，最后都因为安全问题夭折。动态博客比起 Hexo 或 Hugo 这样的好处我想就是方便发布和管理文章吧，因为动态博客往往都自带有后台管理系统，这也是极易出现安全问题的方面。
经历了这些后，现在觉得极简才是真理，一个优秀的博客系统需要拥有的特性无非就是：
良好的 SEO 方便的文章管理机制 安全性 其中第一项 SEO（搜索引擎优化）不论是静态还是动态，现在都可以配置到很好的效果，因为从原理上讲，动态博客通常是由服务端现获取数据来返回的 HTML 内容，而静态则是提前将数据渲染成 HTML 文件再交给托管服务托管。所以 SSR 效果两者大同小异，剩下的就看搜索引擎给不给力了。另外在分布式时代，博客响应性能也大部分交给 CDN 平台决定，和博客系统本身关系不大。
第二项是动态博客系统的优势，对于静态博客，会稍微麻烦一点。因为其博客构建阶段在本地完成，所以每次想要更新就不得不打开电脑运行命令来重新生成整个博客网页资源，再使用命令发布到托管平台。但其实可以利用第三方 CI/CD 平台，如 travis，再结合代码托管平台，如 GitHub，来完成自动构建+部署的功能，作者就只需要将注意力集中在文章撰写上。本博客站就使用的是 GitHub 自带的 Actions 来实现的自动构建和部署（具体方法下次再补上吧，下次一定！），总之我每次只需要将文章提交到 GitHub，它便会自动为我构建好网页代码资源，然后将其部署到我的个人域名 xjj.</description></item><item><title>哈喽 👋</title><link>https://xjj.pub/about/</link><pubDate>Sun, 18 Jul 2021 11:24:06 +0800</pubDate><guid>https://xjj.pub/about/</guid><description>大家好！我是 XJJ，不是洗洁精也没有想静静，你可能是通过我的网名「被门夹过的核桃还补脑吗」认识我的，当然现在可能也叫小丽。我的特点有：
理想主义 懂点理论物理 会点技术 接受过义务教育的义务教育漏网之鱼 LSP 这是我第三次开始写博客，之前两次没能坚持下去可能都是因为使用了别人的博客主题(借口)，所以这次索性先写了个主题再搭博客。目前已经可以在 Hugo 主题官网 上下载使用这款叫 Minima 的主题。自己挺喜欢的这个主题的，在保持简洁的同时，有些其他主题没有的功能。同时，该主题集成了我写的一个评论插件 OvO。和 Waline 一样，OvO 可以嵌入在其他网页上，为其提供评论功能。
为什么非要写博客？诶，就是玩儿！😅 大概是因为这样：
我不是程序员，也不是设计师，我只是恰好有一些想法和一台电脑。
没错，就是平时 🧠 里经常产生想法，无论是技术的还是生活的，也无论是熟悉的领域的还是不熟悉的领域的。时间久了，有些想法还会重复出现。所以，当尝试着将这些想法记录下来，可能是一种解脱。不过，由于平时并没有较多的精力来记录，所以你会看到前几年只有稀稀散散几篇文章，另外还删了几篇物理上的文章。不过我想今后应该会有所改善，并尽量多记录下技术钻研上，但不会记录技术学习之类的总结，因为这些东西一搜一大把，我更愿意记录自己的思考，小到技术大到宇宙。有些文章中表达的想法可能比较激进，就当我是在圈地自萌～
最后，若你恰好看到这个博客网站，又恰好看到这一行字，这是我的 在线简历 🤗。</description></item><item><title>实现了个 brainfuck 解释器</title><link>https://xjj.pub/tech/brainfuck/</link><pubDate>Fri, 02 Jul 2021 14:38:08 +0800</pubDate><guid>https://xjj.pub/tech/brainfuck/</guid><description>安装 首先 clone 仓库 或直接 点击这 下载源码，然后使用下面命令编译安装。
1 2 make make install 原理 Brainfuck 运行在一组内存单元格上，每个格子的初始值为零，并只使用一个指针来操作这些单元格，具体语法如下表所示。
指令 作用 &amp;gt; 将指针右移一格 &amp;lt; 将指针左移一格 + 将指针当前所指单元格的值加1 - 将指针当前所指单元格的值减1 . 打印指针当前所指单元格的值对应的ACSCII字符 , 从键盘获取一个字符存入指针当前所指单元格 [ 若指针当前所指单元格的值为0，则跳转到与之对应的]处继续执行 ] 若指针当前所指单元格的值不为0，则跳回与之对应的[处继续执行 可以看出，brainfuck 只有一个指针、输入输出和循环功能，但它是 图灵完备 的，可以实现和图灵机等同的功能。esolangs.org 上还收集了许多基于 brainfuck 的另类编程语言。
Hello world 老规矩，认识一门语言从打印 Hello World!</description></item><item><title>万物皆弹簧</title><link>https://xjj.pub/idea/tayor-expansion/</link><pubDate>Mon, 03 Feb 2020 18:34:00 +0800</pubDate><guid>https://xjj.pub/idea/tayor-expansion/</guid><description>你要是上过幼儿园小班呢，应该知道势能是位置的函数，表示为 $V(\textbf{r})$，其中 $\textbf{r}$是位矢。在一范围内若某个点的势能达到极小值，则称该点为稳态点 $\textbf{r}_s$，即
对势能函数在稳态点使用泰勒展开并忽略 2 阶后的项得到
$$ V(\textbf{r})=V(\textbf{r}_s)+V^{'}(\textbf{r}_s)(\textbf{r}-\textbf{r}_s)+\frac{V^{''}(\textbf{r}_s)}{2!}(\textbf{r}-\textbf{r}_s)^2 $$
然后把稳态点当作零势能参考点，则有
$$ V(\textbf{r}_s)=0 $$
联立这三个式子得到稳态点处势能的低阶近似为
$$ V(\textbf{r})\approx\frac{V^{''}(\textbf{r}_s)}{2!}(\textbf{r}-\textbf{r}_s)^2 $$
这是势能关于位置的二次函数，其中 $V^{''}(\textbf{r}_s)$ 为某个常数 $k$。
到这儿，要是你还有幸上过幼儿园大班的话，应该知道「力」是势能对位置的导数，所以稳态点附近的粒子受到的力为
$$ \textbf{F}(\textbf{r})=-\frac{dV(\textbf{r})}{d\textbf{r}}=-k(\textbf{r}-\textbf{r}_s) $$
其中 $\textbf{r}-\textbf{r}_s$ 表示在稳态点附近的位移变化，用 $\Delta{\textbf{r}}$ 表示吧。
若是一维的情况，上式变为
$$ \textbf{F}(\textbf{x})=-k\Delta{\textbf{x}} $$
这不就是「胡克定律」吗，即弹簧的弹力与其位移变化量成正比。其中的负号表示该力为吸引力。
这告诉我们在稳态点附近的受力情况可以不依赖势能函数的具体形式，只跟位置变化量成正比关系，近似一种弹簧的弹力。
出现在稳态点附近的运动无处不在，小到固体中原子因与附近原子相互作用而产生的震动，大到你这几天躺床上强行被叫起来吃饭时心里产生的扰动，都可以看成是弹力的作用。所以人类的本质其实是弹簧，你越处在使自己舒适的地方，你就越靠近你的稳态点，你受力的低阶近似就越精确，你就越是根弹簧。</description></item><item><title>关于「信息量大」这句话</title><link>https://xjj.pub/idea/entropy/</link><pubDate>Fri, 03 Jan 2020 19:40:53 +0800</pubDate><guid>https://xjj.pub/idea/entropy/</guid><description>前几天在知乎上看到一个问题：一句话的信息量能大到什么程度？看到评论区很多回复像
对方正在输入&amp;hellip; 一切皆有可能 呵呵…… 之类的，还获得了很多的点赞。当时突然想什么是信息，什么又是信息量？当你面对一件事情，难道不是那些有用的数据对你来说才是信息吗，其他的干扰应该是噪声啊。比如你和一个人聊天，对方给你的回复才是信息呀，而显示 “对方正在输入&amp;hellip;”，并不会让你知道对方要说什么，这句话提供的信息仅仅是“对方正在干回复这件事儿”，而对方要回复的内容是什么，还是有很大的不确定性，这个不确定性是用信息熵来衡量的。
所以我们一直在把信息和信息熵混用。像上面三句话其实是信息熵很大，而信息量反而是很小的，因为你并不能从这些话里的出什么确切的结论。
”一切皆有可能“ 这句话更是直接告诉了你信息熵相当的大。为什么一切皆有可能？是因为你还没有得到足够多的信息来减小事情的不确定性。举个最简单的例子，你的沙雕同学抢了你的硬币，并让你猜在他哪只手里，在他告诉你答案之前，你对硬币在他哪只手是不确定的，现在他告诉你他的左手没有硬币，若他没有说谎，那么他就给了你信息，让你对硬币在他哪只手的不确定性从1降到了2/3，也就是说你的沙雕同学给你了1/3的信息，这1/3的信息通过声波传给了你。
故对于任何事情，你得通过各种方法去收集信息来消灭不确定性，减小信息熵。所以今晚吃什么 😵</description></item><item><title>怎么和最喜欢的人在一起？</title><link>https://xjj.pub/idea/e/</link><pubDate>Mon, 09 Dec 2019 01:40:53 +0800</pubDate><guid>https://xjj.pub/idea/e/</guid><description>你一生中会遇到很多的人，那么如何用最少的交往次数，找到最好的那个和他在一起呢？当然你说你就要全部试一遍，那我也阻止不了你。
首先，你可以先试着和几个人在一起(滑稽)，一段时间后，不管他们有多好，都甩了他们。然后接下来遇到的人，只要比前面被你甩的任何一个人好，就和他一起私奔。好了现在来把问题公式化一下(哎～别走呀，听我说完嘛)
假设有 n 个人，你要放弃前 k 个，从第 k+1 个开始，遇到比前 k 个好的就和他在一起，求 k 为多少使得最好的人被你选中的概率最大。
我们设
事件 $A$ 为：最好的人被你选中
事件 $B_i$ 为：第 i 个人是最好的
我们有全概率公式 $$ P(A)=\sum_{i=k+1}^{n}{P(B_i)P(A|B_i)} $$
其中，这 n 个人是均匀分布的，$P(B_i)$ 就为 $\frac{1}{n}$，所以只要求出 $P(A|B_i)$，就能算出最好的人被你选到的概率 $P(A)$ ，然后再使 $P(A)$ 的导数等于零，就能解出 k 了。
而 $P(A|B_i)$ 表示在第 i 个人是最好的那个人而这个人恰好被你选到的概率。那第 i-1 个就没有前 k 个好，而第 i-1 个没有前 k 个好的概率为 $\frac{k}{i-1}$，所以
$$ P(A)=\frac{1}{n}\sum_{i=k+1}^{n}{\frac{k}{i-1}}=\frac{k}{n}\sum_{i=k+1}^{n-1}{\frac{1}{i}} $$
假设 n 很大很大，也就是你会遇到很多很多的人，我们令 $x=\frac{k}{n}, f(t)=\frac{1}{t}$，上式可以转换为定积分
求 $P(A)$ 极值，令
$$ \frac{dP(A)}{dx}=\frac{d(-xlnx)}{dx}=1-lnx=0 $$
得到 $x=\frac{1}{e}$ ，所以 $k=\frac{n}{e} $</description></item><item><title>朴素贝叶斯分类器</title><link>https://xjj.pub/idea/bayes/</link><pubDate>Sun, 10 Nov 2019 13:52:53 +0800</pubDate><guid>https://xjj.pub/idea/bayes/</guid><description>这篇文章将对朴素贝叶斯分类器进行简单描述和公式推导，并以性别预测为例来理解其「朴素」的原因，最后你应该能根据文章的描述编写一个简单的由人的姓名预测其性别的小程序。阅读前你可能需要懂一些概率论的知识，比如条件概率、贝叶斯公式等等。
基本原理 我们在小学二年级学过贝叶斯公式：
$$ P(B|A)=\frac{P(B)P(A|B)}{P(A)} \tag{1} $$
通过该式子，我们可以算出在已知事件A发生的条件下，事件B发生的概率。比如1当我们看到室友抽屉里藏女士内衣，则室友是个变态的概率就是遇到变态室友的概率乘室友是个变态还喜欢把内衣放抽屉里的概率再除以室友抽屉里有内衣的概率。是不是非常的啊妹zing呀？这里面其实蕴含着「贝叶斯学派」独有的思想，即「后验概率」的思想。感兴趣的同学可以深入了解一下。
现在我们假设上式中的事件A由很多事件构成，即：
$$ A=A_1 \cap A_2 \cap &amp;hellip; \cap A_n $$
则我们的贝叶斯公式变成：
$$ P(B|A_1 A_2 &amp;hellip; A_n)=\frac{P(B)P(A_1 A_2 &amp;hellip; A_n|B)}{P(A_1 A_2 &amp;hellip; A_n)} \tag{2} $$
这其实已经是一个分类器的模型了。我们不妨将事件B看成一推数据的分类结果，将 $A_1,A_2,&amp;hellip;,A_n$ 看成是导致该结果的因素或者叫特征（以下统称特征），则等号左边表示的就是我们的数据属于分类 $B$ 的概率，当其达到某个阈值，我们可以认为该推数据就属于某个分类。
要得到等号左边是多少，我们得从已有的数据中找到等号右边的三项的值。其中 $P(B)$ 可以通过统计数据集中 $B$ 类样本出现的频次得到，即：
$$ P(B)=\frac{B类样本个数}{样本总个数} $$
但剩下的两项很难从有限的数据中直接得出。对于 $P(A_1 A_2 &amp;hellip; A_n|B)$，我们假设所有的特征相互独立，则我们就有： 2
$$ P(A_1 A_2 &amp;hellip; A_n|B)=\prod_{i=1}^{n}{P(A_i|B)} \tag{3} $$
其中 $P(A_i|B)$ 是容易从数据集中直接得到的，分为离散和连续两种情况：
当 $A_i$ 为离散型随机变量时 $$ P(A_i|B)=\frac{B类中有特征A_i的数据个数}{B类数据个数} $$
当 $A_i$ 为连续型随机变量时 假设 $A_i|B$ 符合期望为 $\mu_{ki}$，方差为 $\sigma^2_{ki}$ 的正态分布，则有：</description></item><item><title>卷纸理论</title><link>https://xjj.pub/idea/roll/</link><pubDate>Sun, 13 Jan 2019 13:28:34 +0800</pubDate><guid>https://xjj.pub/idea/roll/</guid><description>假装分析
不妨将卷纸考虑成刚性卷纸，即纸张是不发生径向形变的理想纸张，且每层完全贴合。则卷纸缠绕方式如图：
其中，$r_0$ 为纸筒的半径，$\epsilon$ 为每张纸的厚度。从第一象限开卷并终止于第四象限。过起点做纸筒的切线，将切点与纸筒中心相连得直线 $L_1$，$L_1$ 与 $x$ 轴夹角为 $\theta$ 再过起点做 $L_1$ 的平行线 $L_2$。于是第四象限被直线 $L_1$ 和 $L_2$ 分成三个区域 $A_1$, $A_2$, $A_3$。
因为纸是不发生径向形变的理想纸，所以 $A_1$, $A_3$ 区域里每层纸构成同心圆弧，区域 $A_2$ 的纸不发生弯曲且长度为 $d$。显然，每一圈纸卷了 $2\pi$ 弧度和 $d$ 长度后与下一圈连接。于是有：
$$ \theta=arccos\frac{r_0}{r_0+\epsilon} \tag{1} $$
$$ d=r_0tan\theta \tag{2} $$
考虑 $r_0&amp;raquo;\epsilon$，即纸筒半径远大于纸张厚度的情况下有
$$ \theta\approx arccos\frac{r_0}{r_0}=0 $$
进而有 $d\approx0$，即可以忽略掉区域 $A_2$。所以每圈纸实际上可以看成是同心圆，进而可以很简单地求出卷纸的总长，即同心圆地周长之和。再通过总长对时间的导数就能得出卷纸半径的变化率了。
卷纸总长
考虑到纸的厚度，第 $k$ 圈的平均半径为：
$$ \bar{r}_k = r_0+(k-\frac{1}{2})\epsilon\tag{3} $$
所以卷纸总长为：
$$ \begin{aligned} L&amp;amp;=\sum_{k=1}^{n}{2\pi\bar{r}_k} \cr &amp;amp;=2\pi \Big( nr_0+\epsilon\sum_{k=1}^{n}{\frac{2k-1}{2}}\Big) \cr &amp;amp;=2\pi\Big(nr_0+\frac{n^2}{2}\Big) \end{aligned} $$</description></item></channel></rss>